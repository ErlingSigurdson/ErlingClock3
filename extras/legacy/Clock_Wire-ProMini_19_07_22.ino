/*
  *** ОБЩЕЕ ОПИСАНИЕ ***
  Этот скетч для Arduino позволяет сделать электронные часы.
  
  Под его управлением микроконтроллер (МК) считывает значения текущего времени (часы, минуты и секунды) c микросхемы часов реального времени (RTC) через интерфейс I2C
  и затем посредством микросхемы 74HC595 (также известна как просто "595") выводит их на 4-знаковый светодиодный дисплей с 4 общими катодами. Текущее время можно
  настроить при загрузке скетча или (что гораздо удобнее в процессе эксплуатации) с помощью кнопок настройки.

  Скетч работает с RTC DS3231 или DS1307. Эти микросхемы имеют одинаковые I2C-адреса (как собственные адреса микросхем, так и адреса регистров), поэтому скетч совместим
  с обеими моделями без необходимости внесения модификаций. Точность часов зависит от установленного кварцевого резонатора, температурного режима и наличия температурной
  стабилизации (у DS3231 она имеется).

  Изначально скетч написан для проекта на основе китайского клона Arduino Pro Mini с установленным МК ATmega328P, но при минимальной модификации (в основном требуется
  изменить номера выводов) может работать практически на любом МК AVR семейства ATmega и на МК LGT8F328P.

  *** ВЫВОД НА ДИСПЛЕЙ ***
  Для начала оговоримся насчёт терминов:
  1) Знак – это группа светодиодов на дисплее, образующая отдельный 7-сегментный индикатор. Таким образом, на 4-знаковом дисплее есть знаки 1, 2, 3 и 4 (слева направо).
  2) Цифра – это, собственно, цифра десятичной системы счисления, отображаемая или подлежащая отображению на 7-сегментном индикаторе (на определённом знаке).
  Например, если на часах 13:37, то на знаке 1 отображается цифра 1, на знаках 2 и 3 отображается цифра 3 и на знаке 4 отображается цифра 7.
  
  В управлении дисплеем применяется мультплексирование. Этот метод заключается в том, что в любой момент времени на дисплее включён только один знак, но МК
  последовательно переключает знаки с такой частотой, что для человека все четыре знака кажутся горящими одновременно. Это упрощает аппаратную часть прибора
  (уменьшает необходимое количество управляющих выводов) и снижает его энергопотребление.
  
  Для мультиплексирования между каждым катодом дисплея и землёй устанавливается маломощный NPN-транзистор, который управляется непосредственно с МК. Эмиттеры
  транзисторов подключены к земле, коллекторы – к соответствующим катодам дисплея, базы – к соответствующим выводам МК. Если транзистор закрыт, ток через
  соответствующий ему знак не течёт и никакая цифра на этом знаке не отображается. МК по очереди включает каждый транзистор и выключает все транзисторы, кроме
  активного.

  *** ЗАМЕТКИ ***
  Официальное название I2C-совместимого интерфейса у МК AVR – "Two-wire interface" ("TWI"). Он практически ничем не отличается от I2C, поэтому простоты ради
  далее в комментариях название "TWI" не используется, вместо него употребляется более распространённое обозначение "I2C".
*/

// Подключение библиотеки Wire, которая отвечает за использование интерфейса I2C.
#include <Wire.h>


/*******************************************************************************************************
                                         ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ
*******************************************************************************************************/

// В этих переменных будет храниться текущее время.
uint8_t RTC_hours;
uint8_t RTC_minutes;
uint8_t RTC_seconds;                   // Секунды не будут отображаться на дисплее, но скетч всё равно их считывает, чтобы привязать
                                       // к их течению мигание точки, визуально разделяющей на дисплее часы и минуты.

// В этих переменных будут храниться цифры, выводимые на дисплей.
uint8_t hours_first_digit;
uint8_t hours_second_digit;
uint8_t minutes_first_digit;
uint8_t minutes_second_digit;
uint8_t seconds_first_digit;
uint8_t seconds_second_digit;

// 7-битный I2C-адрес RTC.
const int RTC_SLA = 0x68;

// 8-битные I2C-адреса регистров RTC.
const int DS3231_HOURS = 0x02;
const int DS3231_MINUTES = 0x01;
const int DS3231_SECONDS = 0x00;
// Вообще-то регистров в RTC больше, но нам нужны только эти три.

// Выводы МК, подающие сигналы на базы транзисторов, соединяющих землю и катоды дисплея.
const uint8_t D1_PIN = 9;
const uint8_t D2_PIN = 8;
const uint8_t D3_PIN = 7;
const uint8_t D4_PIN = 6;

// Выводы МК, управляющие микросхемой 595.
// 595 преобразует последовательные сигналы с МК в 8 параллельных сигналов, уровни которых задают отображаемую цифру.
const uint8_t DATA_PIN = 4;
const uint8_t LATCH_PIN = 2;
const uint8_t CLOCK_PIN = 3;

uint8_t previous_RTC_seconds;                   // Используется, чтобы привязать периодичность передачи данных через UART к счётчику секунд RTC.
bool initial_RTC_seconds_was_stored = 0;        // Флаг. Делает так, что первоначальная точка отсчёта периодичности передачи данных через UART задаётся только один раз.

bool settime_mode = 0;                          // Флаг, определяющий включение/выключение режима установки времени.

// Выводы МК, к которым подключены кнопки настройки времени.
const uint8_t SETTIME_TOGGLE_PIN = 10;
const uint8_t SETTIME_HOURS_PIN = 12;
const uint8_t SETTIME_MINUTES_PIN = 11;

// Флаги, используемые для нейтрализации дребезга контактов кнопок.
bool settime_toggle_button_is_pressed;
bool settime_toggle_button_wasnt_pressed;
bool settime_hours_button_is_pressed;
bool settime_hours_button_wasnt_pressed;
bool settime_minutes_button_is_pressed;
bool settime_minutes_button_wasnt_pressed;

// В этих переменных хранятся промежуточные значения, которые пользователь выбирает в режиме установки времени и которые впоследствии записываются в RTC.
uint8_t settime_hours;
uint8_t settime_minutes;
uint8_t settime_seconds;


/*******************************************************************************************************
                                               ФУНКЦИИ
*******************************************************************************************************/

/*
  Функции bcd_to_normal() и normal_to_bcd()
  
  Значения времени хранятся в соответствующих 8-битных регистрах RTC в формате "binary-coded decimal" ("BCD"), а именно в его разновидности
  "packed binary-coded decimal" ("packed BCD"). Это означает, что десятки закодированы в четырёх старших битах, а единицы – в четырёх младших.
  
  Например:
    – Код 01010011 соответствует десятичному числу 53, а не 83, как получилось бы при обычном переводе из двоичной системы счисления в десятичную.
    – Десятичное число 14 соответствует коду 00010100, а не 00001110, как получилось бы при обычном переводе из десятичной системы счисления в двоичную.
  
  Поэтому скетч при считывании времени должен правильно извлекать данные о десятках и единицах и соединять их, чтобы получать искомые числа в обычном формате,
  а при установке времени, наоборот, должен переводить задаваемые значения в код BCD. Эти задачи соответственно выполняют функции bcd_to_normal() и normal_to_bcd().
*/

uint8_t bcd_to_normal(uint8_t bcd) {      // Функция принимает в качестве аргумента код BCD.
  
  // Чтобы получить десятки, функция берёт исходный код BCD, сдвигает 4 старших бита вправо на 4 разряда и умножает получившееся число на 10.
  // Чтобы получить единицы, функция берёт исходный код BCD и просто гасит 4 старших бита.
  // Сложение десятков и единиц даёт искомое число в обычном формате.
  uint8_t normal = 10 * (bcd >> 4) + (bcd & 0x0F);
  return normal;                          // Функция возвращает число в обычном формате.
}

uint8_t normal_to_bcd(uint8_t normal) {   // Функция принимает в качестве аргумента число в обычном формате.
  // Функция находит в заданном числе десятки путём деления на 10 нацело и смещает получившееся значение влево на 4 разряда, таким образом кодируя его в 4 старших битах.
  // Функция находит в заданном числе единицы путём деления на 10 и взятия остатка и затем с помощью побитовой операции ИЛИ записывает результат в 4 младших бита.
  uint8_t bcd = (normal / 10 << 4) | (normal % 10);
  return bcd;                             // Функция возвращает код BCD.
}


/*
  Функции read_time_register() и write_to_time_register() 
 
  МК взаимодействует с RTC с помощью протокола I2C. Управление обменом данными реализовано с помощью классической библиотеки для Arduino – Wire.h,
  работающей с аппаратным интерфейсом I2C. Чтение и запись значений времени соответственно выполняются функциями read_time_register() и write_to_time_register().
  
  Когда МК хочет считать с RTC значение времени, происходит следующее:  
  1) МК передаёт адрес регистра, значение которого нужно считать.
  2) RTC устанавливает на обозначенный регистр маркер.
  3) МК запрашивает данные с RTC.
  4) RTC передаёт значение времени (один байт) из регистра, на котором установлен маркер.
  5) МК записывает значение времени во внутренний буфер.
  6) МК считывает значение времени из буфера для дальнейшей обработки.

  Когда МК хочет записать в RTC значение времени, происходит следующее:  
  1) МК передаёт адрес регистра, значение которого нужно перезаписать.
  2) RTC устанавливает на обозначенный регистр маркер.
  3) МК передаёт новое значение времени (один байт).
  4) RTC записывает новое значение времени в регистр.
 
  Отметим, что теоретически маркер на регистр RTC можно было бы установить единожды, поскольку он не исчезает после завершения сеанса передачи данных.
  Но поскольку скетч регулярно и последовательно считывает значения часов, минут и секунд, ему приходится каждый раз переключать "активный" регистр RTC.
  Отсюда и необходимость каждый раз устанавливать маркер заново.

  Это довольно абстрактное описание, не раскрывающее деталей обмена пакетами данных между МК и RTC через I2C.
  Подробнее об I2C рекомендую читать в даташите ATmega328P, там приведено весьма удачно составленное описание протокола.
*/

uint8_t read_time_register(uint8_t reg){
  Wire.beginTransmission(RTC_SLA);                       // МК обращается к RTC с целью передачи данных (адреса регистра).
  Wire.write(reg);                                       // МК передаёт адрес регистра, значение которого нужно считать.
  Wire.endTransmission();                                // МК завершает сеанс передачи данных, в рамках которого он передавал данные. Шина данных I2C освобождается.
  Wire.requestFrom(RTC_SLA, 1);                          // МК обращается к RTC с целью чтения данных, RTC передаёт значение времени (один байт).
  return bcd_to_normal(Wire.read());                     // Полученное значение считывается из внутреннего буфера МК,
                                                         // переводится из BCD в обычный формат и возвращается функцией.
}

void write_to_time_register(uint8_t reg, uint8_t data) {   
  Wire.beginTransmission(RTC_SLA);                       // МК обращается к RTC с целью передачи данных (адреса регистра).
  Wire.write(reg);                                       // МК передаёт адрес регистра, значение которого нужно перезаписать.
  Wire.write(normal_to_bcd(data));                       // МК передаёт новое значение времени (один байт), переведённое из обычного формата в BCD.
  Wire.endTransmission();                                // МК завершает сеанс передачи данных, в рамках которого он передавал данные. Шина данных I2C освобождается.
}


/*
  Функция refresh_time()

  Последовательно опрашивает регистры RTC и записывает значения часов, минут и секунд в соответствующие глобальные переменные.
  После этого записывает десятки и единицы в отдельные переменные для дальнейшего вывода на дисплей.

  Вероятно, можно было бы уйти от глобальных переменных и сделать так, чтобы функция возвращала соответствующие цифры, но при создании скетча
  было удобнее оперировать именно глобальными переменными.
*/

void refresh_time() {
  RTC_hours = read_time_register(DS3231_HOURS);
  RTC_minutes = read_time_register(DS3231_MINUTES);
  RTC_seconds = read_time_register(DS3231_SECONDS);

  hours_first_digit = RTC_hours / 10;
  hours_second_digit = RTC_hours % 10;
  minutes_first_digit = RTC_minutes / 10;
  minutes_second_digit = RTC_minutes % 10;
  seconds_first_digit = RTC_seconds / 10;
  seconds_second_digit = RTC_seconds % 10;
}


/*
  Функция serial_output()

  Выводит текущие значения времени в терминал через UART.
  Введена в основном для отладки работы скетча, но может пригодиться на случай, если в скетч понадобится добавить связанный с UART функционал. 
*/

void serial_output() {
  if (!initial_RTC_seconds_was_stored) {
    previous_RTC_seconds = RTC_seconds;                  // Задаётся точка отсчёта секунд.
    initial_RTC_seconds_was_stored = 1;                  // Флаг поднимается, потому что первоначальную точку отсчёта нужно задать только один раз.
  }

  if (RTC_seconds != previous_RTC_seconds) {             // Данные выводятся в терминал раз в секунду, с каждым изменением значения RTC_seconds.
    Serial.print(RTC_hours);
    Serial.print(':');
    Serial.print(RTC_minutes);
    Serial.print(':');
    Serial.println(RTC_seconds);
    previous_RTC_seconds = RTC_seconds;
  }
}


/*
  Функция display_digit()

  Осуществляет вывод цифр на дисплей.
*/

void display_digit(uint8_t current_cathode, uint8_t digit_to_display, uint8_t whether_dot_is_used) {
/*
  Первый аргумент определяет номер знака, на котором отображается цифра.
  Второй аргумент соответствует цифре, которая выводится на дисплей.
  Третий аргумент определяет, будет ли у соответствующего знака гореть 8-й сегмент (точка).
*/

  // С помощью первого аргумента включаем нужный знак.
  digitalWrite(D1_PIN, current_cathode == D1_PIN ? 1 : 0);
  digitalWrite(D2_PIN, current_cathode == D2_PIN ? 1 : 0);
  digitalWrite(D3_PIN, current_cathode == D3_PIN ? 1 : 0);
  digitalWrite(D4_PIN, current_cathode == D4_PIN ? 1 : 0);

  /*
    Для отображения цифр используется набор "байт-масок", то есть последовательностей нулей и единиц, которые, будучи выведенными на выходы микросхемы 595,
    включают светодиоды таким образом, что светится определённая цифра. Само собой, байт-маски должны подобраны в соответствии с тем, в какой последовательности
    (в какой комбинации) выводы дисплея подключены к выводам 595.  
    
    В проекте, для которого был создан данный скетч, байт-маски составлены исходя из следующей комбинации подключения:

    Пины 595:         Выводы дисплея:
    Q7 (пин 7)  <---> сегмент D
    Q6 (пин 6)  <---> сегмент A
    Q5 (пин 5)  <---> точка
    Q4 (пин 4)  <---> сегмент F
    Q3 (пин 3)  <---> сегмент C
    Q2 (пин 2)  <---> сегмент B
    Q1 (пин 1)  <---> сегмент G
    Q0 (пин 15) <---> сегмент E

    Номер в названии вывода (Qn) соответствует номеру бита в байт-маске.
    Если в вашем проекте эта комбинанция отличается, то байт-маски нужно будет изменить.
    
    Не забудьте подключить резисторы между выводами Qn микросхемы 595 и выводами дисплея, соответствующими сегментам знаков.
    Теоретически рекомендуемый номинал резисторов – от 510 Ом до 1 кОм, но на практике схема работает даже с резисторами очень маленьких номиналов. 
  */
   
  uint8_t output_matrix[] = {
    0b11011101,  // 0
    0b00001100,  // 1
    0b11000111,  // 2
    0b11001110,  // 3
    0b00011110,  // 4
    0b11011010,  // 5
    0b11011011,  // 6
    0b01001100,  // 7
    0b11011111,  // 8
    0b11011110   // 9
  };

  // Точка будет гореть, только если третий аргумент имеет значение ИСТИНА и счетчик секунд показывает чётное значение.
  // Таким образом, раз в секунду точка загорается или гаснет.
  bool if_blink = whether_dot_is_used && seconds_second_digit % 2 == 0 ? 1 : 0;

  /*
  Вывод данных на дисплей осуществляется с помощью стандартной функции Arduino – shiftOut().
  
  Как уже было упомянуто, 595 преобразует последовательные сигналы с МК в 8 параллельных сигналов (байт-маску), уровни которых задают отображаемую цифру. Поэтому 595
  называют регистром типа "Serial in, parallel out" ("SIPO)". Однако действительности в микросхеме совмещено целых два 8-битных регистра, назовём их "буферный"
  (типа "Serial in, parallel out", "SIPO") и "выходной" (типа "Parallel in, parallel out", "PIPO"). Каждый раз, когда уровень на пине 11 (пин такта, clock) меняется
  с низкого на высокий, имеющийся на пине 14 (пин данных, data) уровень записывается (сдвигается) в буферный регистр. Таким образом, за 8 тактовых сигналов байт-маска
  целиком загружается в буферный регистр. После этого уровень на пине 12 (пин защёлки, latch), заблаговременно установленный как низкий, меняется на высокий, и
  значения из буферного регистра параллельно переходят в выходной. Выходной регистр физически соединён с пинами Q0...Q7 микросхемы, то есть записанные в нём уровни
  непосредственно влияют на состояние схемы.

  Порядок подключения выводов 595 (кроме выводов Qn) в проекте, для которого изначально создавался данный скетч, следующий:

  Пины 595:
         16 <---> VCC
         14 <---> пин 4 Arduino (DATA_PIN)
         13 <---> GND
         12 <---> пин 2 Arduino (LATCH_PIN)
         11 <---> пин 3 Arduino (CLOCK_PIN)
         10 <---> VCC
          8 <---> GND
    Q0...Q7 <---> Согласно байт-маске
  */ 
  digitalWrite(LATCH_PIN, 0);
  shiftOut(DATA_PIN, CLOCK_PIN, MSBFIRST, output_matrix[digit_to_display] | if_blink << 5);    // 5-й бит соответствует точке (согласно байт-маске).
  digitalWrite(LATCH_PIN, 1);

  /*
    При мультиплексировании приходится бороться с явлением, известным как "призрачные цифры". Оно заключается в том, что сегменты 7-сегментного индикатора,
    которые по идее должны быть выключены, немного светятся и этим мешают воспринимать информацию с дисплея. Это обусловлено тем, что, когда МК
    выключает один знак и включает следующий, в регистрах 595 ещё хранится байт-маска предыдущей отображаемой цифры, которая пусть недолго, но задаёт
    комбинацию светящихся сегментов. Чтобы предотвратить это, нужные сегменты оставляются включёнными на 4 такта и затем выключаются на 1 так.
    Благодаря этому в момент включения очередного знака в 595 оказываются записанными сплошь нули, и никакая "призрачная цифра" на дисплй не поступает.
  */
  delay(4);                                             // Включённые сегменты светятся 4 такта.
  digitalWrite(LATCH_PIN, 0);
  shiftOut(DATA_PIN, CLOCK_PIN, MSBFIRST, 0b00000000);  // Все сегменты выключаются.
  digitalWrite(LATCH_PIN, 1);
}


void setup() {
  // Запускаем последовательный порт (опционально, по необходимости).
  Serial.begin(9600);

  // Включаем шину I2C.
  Wire.begin();

  /* 
    При необходимости можно записать в RTC значения времени одновременно с загрузкой скетча в МК.
    Для этого нужно раскомментировать следующие строки с функцией write_to_time_register(), загрузить скетч в МК, снова закомментировать их и загрузить скетч повторно.
    Если скетч с закомментированными строками не загрузить, то МК будет устанавливать в RTC предустановленное значение времени при каждом включении. Обычно это
    нежелательно, поскольку модули DS1307 и DS3231 имеют резервный источник питания, который позволяет им продолжить отчёт времени, даже если МК выключен и основное
    питание отсутствует.
  */
  
  // write_to_time_register(DS3231_HOURS, 9);
  // write_t0_time_register(DS3231_MINUTES, 5);
  // write_to_time_register(DS3231_SECONDS, 45);

  // Включаем пины управления транзисторами в режиме вывода.
  pinMode(D1_PIN, OUTPUT);
  pinMode(D2_PIN, OUTPUT);
  pinMode(D3_PIN, OUTPUT);
  pinMode(D4_PIN, OUTPUT);

  // Включаем пины управления микросхемой 595 в режиме вывода.
  pinMode(DATA_PIN, OUTPUT);
  pinMode(LATCH_PIN, OUTPUT);
  pinMode(CLOCK_PIN, OUTPUT);

  // Включаем пины с подключенными кнопками в режиме ввода и активируем подтягивающие резисторы. 
  pinMode(SETTIME_TOGGLE_PIN, INPUT_PULLUP);
  pinMode(SETTIME_HOURS_PIN, INPUT_PULLUP);
  pinMode(SETTIME_MINUTES_PIN, INPUT_PULLUP);

  // Делаем так, что в момент включения МК все транзисторы будут закрыты.
  digitalWrite(D1_PIN, 0);
  digitalWrite(D2_PIN, 0);
  digitalWrite(D3_PIN, 0);
  digitalWrite(D4_PIN, 0);
}


void loop() {
  // Получаем текущие значения времени с RTC.
  refresh_time();

  // Выводим цифры на дисплей.
  display_digit(D1_PIN, hours_first_digit, 0);
  display_digit(D2_PIN, hours_second_digit, 1);     // Поскольку точка визуально разделяет часы и минуты, она должна гореть только у второго знака.
  display_digit(D3_PIN, minutes_first_digit, 0);
  display_digit(D4_PIN, minutes_second_digit, 0);

  // Выводим текущее время в терминал через UART (опционально, если не нужно, можно просто закомментировать).
  serial_output();

  /*
    Переход к режиму установки времени – вызов функции manual_settime()
    
    Здесь и далее срабатывание кнопок реализовано без прерываний, через определение уровня пинов, включённых в режиме ввода.
    Скетч проверяет уровень пина. Если уровень низкий (пин через нажатую кнопку замкнут на землю), скетч проверяет, не было ли это "дребезгом" контактов.
    Для этого он даёт задержку в 5 миллисекунд и опрашивает пин повторно. Если тот по-прежнему имеет низкий уровень, то скетч считает это штатным нажатием кнопки.
    
    Чтобы скетч перешёл к вызову функции ручной установки времени, кнопки не только должна быть нажата – она должна быть нажата после того, как хотя бы
    ненадолго была отпущена. Это предотвращает бесконечное срабатывание при зажатой кнопке.
  */
  settime_toggle_button_is_pressed = !digitalRead(SETTIME_TOGGLE_PIN);               // Скетч опрашивает пин, отвечающие за перехож в режим ручного ввода времени.
  if (settime_toggle_button_is_pressed && settime_toggle_button_wasnt_pressed) {     // Второе условие – кнопка перед нажатием должна быть отпущена
                                                                                     // (должен быть поднят соответствующий флаг).
    delay(5);                                                                        // Задержка, отсеивающая дребезг от штатного нажатия.
    settime_toggle_button_is_pressed = !digitalRead(SETTIME_TOGGLE_PIN);
    if (settime_toggle_button_is_pressed) {
      manual_settime();                                                              // Вызов функции ручной установки текущего времени.
    }
  }
  settime_toggle_button_wasnt_pressed = !settime_toggle_button_is_pressed;           // Если кнопка была хоть ненадолго отпущена, этот флаг поднимается
                                                                                     // и делает возможными дальнейшие срабатывания.
}


/*
  Функция manual_settime()

  Позволяет установить (задать) новые значения часов и минут с помощью кнопок, не подключая МК к компьютеру.
  Вновь устанавливаемые значения записываются в соответствующие регистры RTC в конце работы функции.
*/

void manual_settime() {
  settime_mode = true;    // Пока этот флаг поднят, функция будет зациклена (см. цикл while ниже), то есть режим установки времени будет включён.
  
  // Устанавливаются некие стартовые значения времени, которые будут выводиться на дисплей непосредственно после включения режима настройки.
  // В ходе настройки пользователь будет менять эти значения, что будет отображаться на дисплее. Так пользователь узнаёт, какие значение времени
  // он выбирает в ходе настройки.
  settime_hours = 0;
  settime_minutes = 0;
  settime_seconds = 0;

  // Стартовые значения также выводятся в терминал через UART (опционально, если не нужно, можно просто закомментировать).
  Serial.print(settime_hours);
  Serial.print(":");
  Serial.print(settime_minutes);
  Serial.print(":");
  Serial.println(settime_seconds);

  // Если кнопка была хоть ненадолго отпущена, этот флаг поднимается и делает возможными дальнейшие срабатывания кнопки переключения режима.
  settime_toggle_button_wasnt_pressed = !settime_toggle_button_is_pressed;
      
  /*
    Цикл, в рамках которого:
    – На дисплей выводятся не значения времени, получаемые с RTC, а промежуточные значения, выбираемые пользователем и готовые к отправке в RTC в качестве новых текущих значений.
    – Пользователь посредством нажатия кнопок (опрос пинов и поднятие флагов осуществляются так же, как это было описано выше) может менять промежуточные значения времени.
  */
  while(settime_mode) {
    
    // Установка часов.
    settime_hours_button_is_pressed = !digitalRead(SETTIME_HOURS_PIN);
    if (settime_hours_button_is_pressed && settime_hours_button_wasnt_pressed) {
      delay(5);
      settime_hours_button_is_pressed = !digitalRead(SETTIME_HOURS_PIN);
      if (settime_hours_button_is_pressed) {
        ++settime_hours;
        if (settime_hours > 23) {
          settime_hours = 0;
        }

        // Вывод промежуточных значений времени в терминал (опционально, если не нужно, можно просто закомментировать).
        Serial.print(settime_hours);
        Serial.print(":");
        Serial.print(settime_minutes);
        Serial.print(":");
        Serial.println(settime_seconds);
      }
    }
    settime_hours_button_wasnt_pressed = !settime_hours_button_is_pressed;

    // Установка минут.
    settime_minutes_button_is_pressed = !digitalRead(SETTIME_MINUTES_PIN);
    if (settime_minutes_button_is_pressed && settime_minutes_button_wasnt_pressed) {
      delay(5);
      settime_minutes_button_is_pressed = !digitalRead(SETTIME_MINUTES_PIN);
      if (settime_minutes_button_is_pressed) {
        ++settime_minutes;
        if (settime_minutes > 59) {
          settime_minutes = 0;
        }

        // Вывод промежуточных значений времени в терминал (опционально, если не нужно, можно просто закомментировать).
        Serial.print(settime_hours);
        Serial.print(":");
        Serial.print(settime_minutes);
        Serial.print(":");
        Serial.println(settime_seconds);
      }
    }
    settime_minutes_button_wasnt_pressed = !settime_minutes_button_is_pressed;

    // Промежуточные значения времени разбиваются на отдельные цифры для дальнейшего вывода на дисплей.
    hours_first_digit = settime_hours / 10;
    hours_second_digit = settime_hours % 10;
    minutes_first_digit = settime_minutes / 10;
    minutes_second_digit = settime_minutes % 10;
    seconds_first_digit = settime_seconds / 10;
    seconds_second_digit = settime_seconds % 10;

    // Промежуточные значения времени выводятся на дисплей.
    display_digit(D1_PIN, hours_first_digit, 0);
    display_digit(D2_PIN, hours_second_digit, 0);                // Точка после второго знака не мигает, что является индикатором режима ручной установки времени.
    display_digit(D3_PIN, minutes_first_digit, 0);
    display_digit(D4_PIN, minutes_second_digit, 0);
   
    // Выход из режима ручной установки времени (снятие флага settime_mode)
    settime_toggle_button_is_pressed = !digitalRead(SETTIME_TOGGLE_PIN);
    if (settime_toggle_button_is_pressed && settime_toggle_button_wasnt_pressed) {
      delay(5);
      settime_toggle_button_is_pressed = !digitalRead(SETTIME_TOGGLE_PIN);
      if (settime_toggle_button_is_pressed) {

        // Промежуточные значения по очереди отправляются в RTC и становятся новыми текущими значениями времени.
        write_to_time_register(DS3231_HOURS, settime_hours);
        write_to_time_register(DS3231_MINUTES, settime_minutes);
        write_to_time_register(DS3231_SECONDS, settime_seconds);
        settime_mode = 0;
      }
    }
    settime_toggle_button_wasnt_pressed = !settime_toggle_button_is_pressed;
  }
}

// (c) Дмитрий Ефимов, 2022 г.
// Скетч распространяется на условиях международной лицензии Creative Commons CC-BY 4.0 https://creativecommons.org/licenses/by/4.0/
// Это означает, что вы можете свободно и бесплатно использовать его любыми не нарушающими закон способами при условии указания автора.
// Хотя если не укажете, я не очень расстроюсь и преследовать вас не буду :D
